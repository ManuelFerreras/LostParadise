pragma solidity >=0.8.0;

import "BaseBuilding.sol";

// SPDX-License-Identifier: MIT

contract BuildingHelper is BuildingsContract {
    
    using SafeMath for uint256;
    
    uint baseStorage = 400;
    uint baseProduction = 750;
    
    // Returns an Array With Owned Building's Ids By Specified Address.
    function getBuildingsByOwner(address _owner) public view returns(uint[] memory) {
        uint[] memory result = new uint[](ownerBuildingCount[_owner]);
        uint counter = 0;
        for (uint i = 0; i < buildings.length; i++) {
            if (buildingToOwner[i] == _owner) {
                result[counter] = i;
                counter++;
            }
        }
        return result;
    }
    
     // Returns an Array With Owned Slot's Ids By Specified Address.
    function getSlotsByOwner(address _owner) public view returns(uint[] memory) {
        uint[] memory result = new uint[](slotsOwnerCount[_owner]);
        uint counter = 0;
        for (uint i = 0; i < slots.length; i++) {
            if (slotToOwner[i] == _owner) {
                result[counter] = i;
                counter++;
            }
        }
        return result;
    }
    

    // Returns LPS Balance Of Specified Address.
    function LPSBalanceOf(address target_) public view returns (uint256) {
        return currency.balanceOf(target_);
    }
    
    // Returns Building's Info.
    function searchBuildingById(uint buildingId_) public view returns (Building memory, uint, uint, uint) {
        return (buildings[buildingId_], returnBuildingStartTime(buildingId_), buildingId_, returnBuildingEarnings(buildingId_));
    }
    
    // Returns Building's Info.
    function searchSlotById(uint slotId_) public view returns (Slot memory, uint) {
        return (slots[slotId_], slotId_);
    }
    
    // Function that Returns True if a Building is Being Used.
    function isUsed(uint _id) public view returns (bool) {
        return buildings[_id].used;
    }
    
    // This Function Returns The Ammount Of Tokens Generated By a Building
    function returnBuildingEarnings(uint buildingId_) public view returns (uint) {
        
        if(isUsed(buildingId_)) {
            uint totalEarnings = (((block.timestamp - buildings[buildingId_].startTime) - (block.timestamp - buildings[buildingId_].startTime) % buildings[buildingId_].finishTime)) / buildings[buildingId_].finishTime * buildings[buildingId_].income;
            totalEarnings = totalEarnings * checkTypes(buildingId_) / 100;
            
            if (totalEarnings > buildings[buildingId_].maxStorage) {
                return buildings[buildingId_].maxStorage;
            } else {
                return totalEarnings;
            }
        } else {
            return 0;
        }
            
    }
    
    // Returns a Time Stamp From When Specified Building Started Producing.
    function returnBuildingStartTime(uint _id) public view returns (uint) {
        if(isUsed(_id)) {
            return block.timestamp - buildings[_id].startTime;
        } else {
            return 0;
        }
    }
    
    // Check Slot With Building Type 
    function checkTypes(uint256 buildingId_) public view returns (uint multiplier_) {
        if (keccak256(abi.encodePacked(slots[slotToBuilding[buildingId_ + 1]].typeOfSlot)) == keccak256(abi.encodePacked(buildings[buildingId_].typeOfBuilding))) {
            return 110;
        } else {
            return 100;
        }
    }
    
    // Returns Random DNA For Mining a Building.
    function _randDna(uint mod_) internal view returns(uint dna, uint door_, uint basement_, uint body_, uint ceiling_, string memory typeOfBuilding_) {
        uint256 door = uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, buildings.length, slots.length))) % mod_ + 1;
        uint256 basement = uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, door, buildings.length, slots.length))) % mod_ + 1;
        uint256 body = uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, basement, buildings.length, slots.length))) % mod_ + 1;
        uint256 ceiling = uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, body, buildings.length, slots.length))) % mod_ + 1;
        
        string memory typeOfBuilding = _getTypeOfPart(body);
        
        return (door + basement * 10 + body * 100 + ceiling * 1000, door, basement, body, ceiling, typeOfBuilding);
    }
    
    // Returns Random DNA From 2 Building For Minting a Building.
    function _randDna(uint mod_, uint dna1_, uint dna2_) internal view returns(uint dna, uint door_, uint basement_, uint body_, uint ceiling_, string memory typeOfBuilding_) {
        uint256 door = uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, dna1_, dna2_, buildings.length, slots.length))) % mod_ + 1;
        uint256 basement = uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, dna1_, dna2_, door, buildings.length, slots.length))) % mod_ + 1;
        uint256 body = uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, dna1_, dna2_, basement, buildings.length, slots.length))) % mod_ + 1;
        uint256 ceiling = uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, dna1_, dna2_, body, buildings.length, slots.length))) % mod_ + 1;
        
        string memory typeOfBuilding = _getTypeOfPart(body);
        
        return (door + basement * 10 + body * 100 + ceiling * 1000, door, basement, body, ceiling, typeOfBuilding);
    }
    
    // Returns a Random Rareness Used For Buildings.
    function _randRareness() internal view returns(string memory rareness) {
        uint256 randRarenessNumber = (uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, buildings.length, slots.length))) % 100) + 1;
        
        if(randRarenessNumber >= 1 && randRarenessNumber <= 60) {
            return "Common";
        } else if(randRarenessNumber >= 61 && randRarenessNumber <= 90) {
            return "Uncommon";
        } else if(randRarenessNumber >= 91 && randRarenessNumber <= 99) {
            return "Rare";
        } else if(randRarenessNumber == 100) {
            return "Legendary";
        }
        
    }
    
    // Returns a Random Type For Slots Generation.
    function _randSlotType() internal view returns(string memory rareness) {
        uint256 randRarenessNumber = (uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, buildings.length, slots.length))) % 4) + 1;
        
        return(_getTypeOfPart(randRarenessNumber));
    }
    
    // Returns Type Based On Part Given.
    function _getTypeOfPart(uint256 num_) internal pure returns (string memory rareness) {
        if(num_ == 1) {
            return "House";
        } else if( num_ == 2) {
            return "Hotel";
        } else if(num_ == 3) {
            return "Business";
        } else if(num_ == 4) {
            return "Dojo";
        }
    }
    
    // Creates Building Storage and Production Amount.
    function _createStorProd(string memory rareness_, uint256[4] memory parts_) internal view returns (uint256, uint256) {
        return ( baseStorage.mul( _getPartsStorageMultiplier(parts_)).mul(_getRarenessMultiplier(rareness_)).div(10000) , baseProduction.mul(_getPartsProductionMultiplier(parts_)).mul(_getRarenessMultiplier(rareness_)).div(10000) );
    }
    
    // Returns Storage Multiplier Based On Building's DNA
    function _getPartsStorageMultiplier(uint256[4] memory parts_) internal pure returns (uint256) {
        return _getStorMultiplier(parts_[0]).add(_getStorMultiplier(parts_[1])).add(_getStorMultiplier(parts_[2])).add(_getStorMultiplier(parts_[3])).div(4);
    }
    
    // Returns Production Multiplier Based On Building's DNA
    function _getPartsProductionMultiplier(uint256[4] memory parts_) internal pure returns (uint256) {
        return _getProdMultiplier(parts_[0]).add(_getProdMultiplier(parts_[1])).add(_getProdMultiplier(parts_[2])).add(_getProdMultiplier(parts_[3])).div(4);
    }
    
    // Returns Type Production Multiplier.
    function _getProdMultiplier(uint256 dna_) internal pure returns (uint256 prod) {
        if (dna_ == 1) {
            return 90;
        } else if (dna_ == 2) {
            return 95;
        } else if (dna_ == 3) {
            return 110;
        } else if (dna_ == 4) {
            return 105;
        }
    }
    
    // Returns Type Storage Multiplier.
    function _getStorMultiplier(uint256 dna_) internal pure returns (uint256 stor) {
        if (dna_ == 1) {
            return 110;
        } else if (dna_ == 2) {
            return 105;
        } else if (dna_ == 3) {
            return 90;
        } else if (dna_ == 4) {
            return 95;
        }
    }
    
    // Returns Multiplier Based On Building's Rareness
    function _getRarenessMultiplier(string memory rareness_) internal pure returns (uint256 mult) {
        if (keccak256(bytes(rareness_)) == keccak256(bytes("Common"))) {
            return 100;
        } else if (keccak256(bytes(rareness_)) == keccak256(bytes("Uncommon"))) {
            return 110;
        } else if (keccak256(bytes(rareness_)) == keccak256(bytes("Rare"))) {
            return 120;
        } else if (keccak256(bytes(rareness_)) == keccak256(bytes("Legendary"))) {
            return 150;
        }
    }
    
    // Updates Building's Production Based on Building's Level
    function _updateLevelRates(uint buildingId_) internal onlyOwnerOfBuilding(buildingId_) {
        (uint newIncome_, uint newStorage_) = upgradeImproval(buildingId_);
        
        buildings[buildingId_].income = newIncome_;
        buildings[buildingId_].maxStorage = newStorage_;
    }
    
    // Get Building's Upgrade Cost
    function getBuildingUpgradeFee(uint buildingId_) public view returns(uint) {
        return baseLevelUpFee * (1 + buildings[buildingId_].level / 100) * 10 ** decimals;
    }
    
    // Get Building's Upgrade Improval
    function upgradeImproval(uint buildingId_) public view returns(uint, uint) {
        if((buildings[buildingId_].level + 1) % 10 == 0) {
            return( buildings[buildingId_].income * (105) / 100, buildings[buildingId_].maxStorage * (105) / 100);
        } else {
            return (buildings[buildingId_].income * (101) / 100, buildings[buildingId_].maxStorage * (101) / 100);
        }
    }
    
    // Checks if Building is Max Leveled
    modifier maxLevelOfBuilding(uint buildingId_) {
        require(buildings[buildingId_].level == maxBuildingLevel);
        _;
    }

}